{"version":3,"file":"index.js","sources":["../../src/index.ts"],"sourcesContent":["// import './creational/creational';\n// import './structural/structural';\n// import './behavioral/behavioral';\n// ------------------------------------\n\n// ==================factory-method=========================\n// interface Subscription {\n//   operation(): string;\n// }\n\n// class GamerSubscription implements Subscription {\n//   public operation(): string {\n//     return 'Gamer';\n//   }\n// }\n\n// class PremiumSubscription implements Subscription {\n//   public operation(): string {\n//     return 'Premium';\n//   }\n// }\n\n// abstract class SubscriptionCreator {\n//   public abstract createSubscription(): Subscription;\n\n//   public manageSubscription(): string {\n//     const subscription = this.createSubscription();\n\n//     return `Managing a ${subscription.operation()} subscription`;\n//   }\n// }\n\n// class GamerSubscriptionCreator extends SubscriptionCreator {\n//   public createSubscription(): Subscription {\n//     return new GamerSubscription();\n//   }\n// }\n\n// class PremiumSubscriptionCreator extends SubscriptionCreator {\n//   public createSubscription(): Subscription {\n//     return new PremiumSubscription();\n//   }\n// }\n\n// const gamerSubscriptionCreator = new GamerSubscriptionCreator();\n// console.log(gamerSubscriptionCreator.manageSubscription());\n\n// const premiumSubscriptionCreator = new PremiumSubscriptionCreator();\n// console.log(premiumSubscriptionCreator.manageSubscription());\n\n// =====================singleton==============================\n// interface ApiResponse {\n//   id: number;\n//   name: string;\n//   data: any;\n// }\n\n// export class ApiManager {\n//   private static instance: ApiManager;\n\n//   private constructor() {}\n\n//   public static getInstance(): ApiManager {\n//     if (!ApiManager.instance) {\n//       ApiManager.instance = new ApiManager();\n//     }\n//     return ApiManager.instance;\n//   }\n\n//   public async get(url: string): Promise<any> {\n//     try {\n//       const response = await fetch(url);\n//       if (!response.ok) {\n//         throw new Error(`HTTP error! status: ${response.status}`);\n//       }\n//       return (await response.json()) as any;\n//     } catch (error) {\n//       console.error('Failed to fetch data:', error);\n//       throw error;\n//     }\n//   }\n// }\n\n// // Використання Singleton для викликів API\n// const apiManager1 = ApiManager.getInstance();\n// const apiManager2 = ApiManager.getInstance();\n\n// export const API_KEY = 'bbcabf34e55a9240d0c44542dbf6e7ac';\n// export const BASE_URL = 'https://api.openweathermap.org/data/2.5/weather';\n\n// apiManager1\n//   .get(`${BASE_URL}?q=Lviv&appid=${API_KEY}&units=metric`)\n//   .then(data => console.log('Data fetched:', data))\n//   .catch(error => console.error('Error fetching data:', error));\n\n// // Перевірка того, що екземпляри є однаковими\n// console.log(apiManager1 === apiManager2); // Виведе: true\n\n// =================builder===============================================\n// interface FlowerBouquetBuilder {\n//   setFlowerType(flowerType: string): this;\n//   setQuantity(quantity: number): this;\n//   setColor(color: string): this;\n//   setNeedsWrapping(needsWrapping: boolean): this;\n//   build(): FlowerBouquet;\n// }\n// class FlowerBouquet {\n//   public flowerType?: string;\n//   public quantity?: number;\n//   public color?: string;\n//   public needsWrapping?: boolean;\n\n//   public describe(): void {\n//     console.log(\n//       `Bouquet details:\\nFlower Type: ${this.flowerType}\\nQuantity: ${this.quantity}\\nColor: ${this.color}\\nNeeds Wrapping: ${this.needsWrapping}`\n//     );\n//   }\n// }\n// class FlowerBouquetBuilderImpl implements FlowerBouquetBuilder {\n//   private bouquet: FlowerBouquet;\n\n//   constructor() {\n//     this.bouquet = new FlowerBouquet();\n//   }\n\n//   public setFlowerType(flowerType: string): this {\n//     this.bouquet.flowerType = flowerType;\n//     return this;\n//   }\n\n//   public setQuantity(quantity: number): this {\n//     this.bouquet.quantity = quantity;\n//     return this;\n//   }\n\n//   public setColor(color: string): this {\n//     this.bouquet.color = color;\n//     return this;\n//   }\n\n//   public setNeedsWrapping(needsWrapping: boolean): this {\n//     this.bouquet.needsWrapping = needsWrapping;\n//     return this;\n//   }\n\n//   public build(): FlowerBouquet {\n//     const result = this.bouquet;\n//     this.reset();\n//     return result;\n//   }\n\n//   private reset(): void {\n//     this.bouquet = new FlowerBouquet();\n//   }\n// }\n\n// // Приклад використання\n// const builder = new FlowerBouquetBuilderImpl();\n\n// const bouquetRoses = builder\n//   .setFlowerType('Roses')\n//   .setQuantity(12)\n//   .setColor('Red')\n//   .setNeedsWrapping(true)\n//   .build();\n\n// bouquetRoses.describe();\n\n// ==========prototype=====================================================\n// class RoseBouquet {\n//   constructor(\n//     public quantity: number,\n//     public color: string,\n//     public needsWrapping: boolean\n//   ) {}\n\n//   clone(): RoseBouquet {\n//     return new RoseBouquet(this.quantity, this.color, this.needsWrapping);\n//   }\n// }\n\n// // Приклад використання\n// const originalBouquet = new RoseBouquet(12, 'Red', true);\n\n// const newBouquet = originalBouquet.clone();\n// newBouquet.quantity = 24;\n\n// console.log(originalBouquet);\n// console.log(newBouquet);\n\n// -------------var-2----------------------------------------------------\n\n// interface Bouquet {\n//   setQuantity(quantity: number): void;\n//   setColor(color: string): void;\n//   setNeedsWrapping(needsWrapping: boolean): void;\n//   clone(): Bouquet;\n// }\n\n// class RoseBouquet implements Bouquet {\n//   constructor(\n//     private quantity: number,\n//     private color: string,\n//     private needsWrapping: boolean\n//   ) {}\n\n//   public setQuantity(quantity: number): void {\n//     this.quantity = quantity;\n//   }\n\n//   public setColor(color: string): void {\n//     this.color = color;\n//   }\n\n//   public setNeedsWrapping(needsWrapping: boolean): void {\n//     this.needsWrapping = needsWrapping;\n//   }\n\n//   public clone(): Bouquet {\n//     return new RoseBouquet(this.quantity, this.color, this.needsWrapping);\n//   }\n// }\n\n// // Приклад використання\n// const originalBouquet: Bouquet = new RoseBouquet(12, 'Red', true);\n// const newBouquet = originalBouquet.clone();\n\n// newBouquet.setQuantity(24);\n// newBouquet.setColor('yellow');\n\n// console.log(originalBouquet);\n// console.log(newBouquet);\n\n// ==========abstract-factory===================================\n// Інтерфейси для продуктів\n// interface ElectricMoped {\n//   start(): string;\n// }\n\n// interface GasolineMoped {\n//   start(): string;\n// }\n\n// // Реалізації для стилю Futuristic\n// class FuturisticElectricMoped implements ElectricMoped {\n//   start(): string {\n//     return 'Стартую на футуристичному електромопеді Альфа';\n//   }\n// }\n\n// class FuturisticGasolineMoped implements GasolineMoped {\n//   start(): string {\n//     return 'Стартую на футуристичному бензиновому мопеді Альфа';\n//   }\n// }\n\n// // Реалізації для стилю Retro\n// class RetroElectricMoped implements ElectricMoped {\n//   start(): string {\n//     return 'Стартую на ретро електромопеді Альфа';\n//   }\n// }\n\n// class RetroGasolineMoped implements GasolineMoped {\n//   start(): string {\n//     return 'Стартую на ретро бензиновому мопеді Альфа';\n//   }\n// }\n\n// // Абстрактна фабрика\n// interface MopedFactory {\n//   createElectricMoped(): ElectricMoped;\n//   createGasolineMoped(): GasolineMoped;\n// }\n\n// // Фабрика для Futuristic стилю\n// class FuturisticMopedFactory implements MopedFactory {\n//   createElectricMoped(): ElectricMoped {\n//     return new FuturisticElectricMoped();\n//   }\n\n//   createGasolineMoped(): GasolineMoped {\n//     return new FuturisticGasolineMoped();\n//   }\n// }\n\n// // Фабрика для Retro стилю\n// class RetroMopedFactory implements MopedFactory {\n//   createElectricMoped(): ElectricMoped {\n//     return new RetroElectricMoped();\n//   }\n\n//   createGasolineMoped(): GasolineMoped {\n//     return new RetroGasolineMoped();\n//   }\n// }\n\n// // Клієнтський код\n// function clientCode(factory: MopedFactory) {\n//   const electricMoped = factory.createElectricMoped();\n//   const gasolineMoped = factory.createGasolineMoped();\n\n//   console.log(electricMoped.start());\n//   console.log(gasolineMoped.start());\n// }\n\n// // Використання\n// const futuristicMopedFactory = new FuturisticMopedFactory();\n// console.log('Futuristic Mopeds:');\n// clientCode(futuristicMopedFactory);\n\n// const retroMopedFactory = new RetroMopedFactory();\n// console.log('\\nRetro Mopeds:');\n// clientCode(retroMopedFactory);\n\n// ==============adapter=========================================\n// interface PcGame {\n//   launch(): string;\n// }\n\n// // Клас, що описує стару гру для приставки\n// class ConsoleGame {\n//   startOnConsole(): string {\n//     return 'Гра для старої приставки.';\n//   }\n// }\n\n// // Адаптер, який дозволяє запустити гру на ПК\n// class ConsoleToPcAdapter implements PcGame {\n//   private readonly consoleGame: ConsoleGame;\n\n//   constructor(consoleGame: ConsoleGame) {\n//     this.consoleGame = consoleGame;\n//   }\n\n//   launch(): string {\n//     return `${this.consoleGame.startOnConsole()} (адаптовано для запуску на ПК)`;\n//   }\n// }\n\n// // Використання\n// const consoleGame = new ConsoleGame();\n// const pcGameAdapter = new ConsoleToPcAdapter(consoleGame);\n\n// console.log(pcGameAdapter.launch());\n\n// =========decorator===========================================\n// Базовий інтерфейс\n// interface Player {\n//   getStats(): string;\n//   getProtectionLevel(): number;\n// }\n\n// // Конкретний компонент: базовий герой\n// class BasicPlayer implements Player {\n//   getStats(): string {\n//     return 'Player: Basic equipment';\n//   }\n\n//   getProtectionLevel(): number {\n//     return 0; // Початковий рівень захисту\n//   }\n// }\n\n// // Базовий декоратор\n// class PlayerDecorator implements Player {\n//   protected player: Player;\n\n//   constructor(player: Player) {\n//     this.player = player;\n//   }\n\n//   getStats(): string {\n//     return this.player.getStats();\n//   }\n\n//   getProtectionLevel(): number {\n//     return this.player.getProtectionLevel();\n//   }\n// }\n\n// // Декоратор: додавання бронежилета\n// class ArmorDecorator extends PlayerDecorator {\n//   getStats(): string {\n//     return `${super.getStats()} + Armor`;\n//   }\n\n//   getProtectionLevel(): number {\n//     return super.getProtectionLevel() + 50; // Додаємо 50 одиниць захисту\n//   }\n// }\n\n// // Декоратор: додавання каски\n// class HelmetDecorator extends PlayerDecorator {\n//   getStats(): string {\n//     return `${super.getStats()} + Helmet`;\n//   }\n\n//   getProtectionLevel(): number {\n//     return super.getProtectionLevel() + 25; // Додаємо 25 одиниць захисту\n//   }\n// }\n\n// // Використання\n// const basicPlayer = new BasicPlayer();\n// console.log(\n//   'Базовий гравець:',\n//   basicPlayer.getStats(),\n//   '| Захист:',\n//   basicPlayer.getProtectionLevel()\n// );\n\n// const playerWithArmor = new ArmorDecorator(basicPlayer);\n// console.log(\n//   'Гравець з бронежилетом:',\n//   playerWithArmor.getStats(),\n//   '| Захист:',\n//   playerWithArmor.getProtectionLevel()\n// );\n\n// const playerWithArmorAndHelmet = new HelmetDecorator(playerWithArmor);\n// console.log(\n//   'Гравець з бронежилетом і каскою:',\n//   playerWithArmorAndHelmet.getStats(),\n//   '| Захист:',\n//   playerWithArmorAndHelmet.getProtectionLevel()\n// );\n\n// ===============bridge======================================\n// // інтерфейс\n// interface Color {\n//   applyColor(): string;\n// }\n\n// class RedColor implements Color {\n//   applyColor() {\n//     return 'червоного кольору.';\n//   }\n// }\n\n// class BlueColor implements Color {\n//   applyColor() {\n//     return 'синього кольору.';\n//   }\n// }\n\n// // Абстракція для моделі мопеда\n// abstract class Moped {\n//   protected color: Color;\n\n//   constructor(color: Color) {\n//     this.color = color;\n//   }\n\n//   abstract displayDetails(): string;\n// }\n\n// // Конкретні моделі мопедів\n// class AlphaMoped extends Moped {\n//   displayDetails() {\n//     return `Мопед Альфа ${this.color.applyColor()}`;\n//   }\n// }\n\n// class KarpatyMoped extends Moped {\n//   displayDetails() {\n//     return `Мопед Карпати ${this.color.applyColor()}`;\n//   }\n// }\n\n// // Використання\n// const alphaRed = new AlphaMoped(new RedColor());\n// const karpatyBlue = new KarpatyMoped(new BlueColor());\n\n// function getDetails(moped: Moped) {\n//   const result = moped.displayDetails();\n//   console.log(result);\n// }\n\n// getDetails(karpatyBlue);\n// getDetails(alphaRed);\n\n// ===============facade=====================================\n// // Підсистема 1: Двигун мопеда\n// class Engine {\n//   start() {\n//     console.log('Двигун запущено');\n//   }\n\n//   stop() {\n//     console.log('Двигун зупинено');\n//   }\n// }\n\n// // Підсистема 2: Ліхтарі мопеда\n// class Lights {\n//   turnOn() {\n//     console.log('Ліхтарі включені');\n//   }\n\n//   turnOff() {\n//     console.log('Ліхтарі вимкнено');\n//   }\n// }\n\n// // Підсистема 3: Кермо мопеда\n// class Handlebar {\n//   turnLeft() {\n//     console.log('Кермо повернуте наліво');\n//   }\n\n//   turnRight() {\n//     console.log('Кермо повернуте направо');\n//   }\n// }\n\n// // Підсистема 4: Колеса мопеда\n// class Wheels {\n//   startMoving() {\n//     console.log('Колеса почали рухатись');\n//   }\n\n//   stopMoving() {\n//     console.log('Колеса зупинились');\n//   }\n// }\n\n// // Facade: спрощений інтерфейс для мопеда Альфа\n// class AlphaMopedFacade {\n//   private readonly engine: Engine;\n//   private readonly lights: Lights;\n//   private readonly handlebar: Handlebar;\n//   private readonly wheels: Wheels;\n\n//   constructor() {\n//     this.engine = new Engine();\n//     this.lights = new Lights();\n//     this.handlebar = new Handlebar();\n//     this.wheels = new Wheels();\n//   }\n\n//   startMoped() {\n//     this.lights.turnOn();\n//     this.engine.start();\n//     this.wheels.startMoving();\n//     console.log('Мопед готовий до поїздки');\n//   }\n\n//   stopMoped() {\n//     this.wheels.stopMoving();\n//     this.engine.stop();\n//     this.lights.turnOff();\n//     console.log('Мопед зупинено');\n//   }\n\n//   turnLeft() {\n//     this.handlebar.turnLeft();\n//   }\n\n//   turnRight() {\n//     this.handlebar.turnRight();\n//   }\n// }\n\n// // Клієнтський код\n// const moped = new AlphaMopedFacade();\n\n// moped.startMoped(); // Запуск мопеда\n// moped.turnLeft(); // Поворот наліво\n// moped.stopMoped(); // Зупинка мопеда\n\n// ==============proxy========================================\n// // Інтерфейс, який описує поведінку сервісу\n// interface DataService {\n//   getData(): string;\n// }\n\n// // Реальний сервіс, який містить основну бізнес-логіку\n// class RealDataService implements DataService {\n//   getData(): string {\n//     return 'Дані з сервісу.';\n//   }\n// }\n\n// // Проксі-сервіс, який додає додаткову логіку, наприклад кешування\n// class CachedDataServiceProxy implements DataService {\n//   private readonly realDataService: RealDataService;\n//   private cachedData: string | null = null;\n\n//   constructor(realDataService: RealDataService) {\n//     this.realDataService = realDataService;\n//   }\n\n//   getData(): string {\n//     if (!this.cachedData) {\n//       console.log('Завантаження даних із основного сервісу...');\n//       this.cachedData = this.realDataService.getData();\n//     } else {\n//       console.log('Повернення кешованих даних.');\n//     }\n//     return this.cachedData;\n//   }\n// }\n\n// // Приклад використання\n// const cachedProxy = new CachedDataServiceProxy(new RealDataService());\n\n// function clientCode(data: DataService) {\n//   data.getData();\n// }\n\n// clientCode(cachedProxy); // Завантаження даних із основного сервісу...\n// clientCode(cachedProxy); // Повернення кешованих даних.\n\n// ===========composite=====================================\n// // Абстрактний клас Компонент\n// abstract class Component {\n//   abstract displayDetails(): void;\n//   abstract getPrice(): number;\n// }\n\n// // Конкретний компонент: частина мопеда\n// class MopedPart extends Component {\n//   private readonly name: string;\n//   private readonly price: number;\n\n//   constructor(name: string, price: number) {\n//     super();\n//     this.name = name;\n//     this.price = price;\n//   }\n\n//   displayDetails(): void {\n//     console.log(`Part: ${this.name}, Price: ${this.price}₴`);\n//   }\n\n//   getPrice(): number {\n//     return this.price;\n//   }\n// }\n\n// // Композитний компонент: мопед\n// class Moped extends Component {\n//   private readonly name: string;\n//   private readonly parts: Component[] = [];\n\n//   constructor(name: string) {\n//     super();\n//     this.name = name;\n//   }\n\n//   addPart(part: Component): void {\n//     this.parts.push(part);\n//   }\n\n//   removePart(part: Component): void {\n//     const idx = this.parts.indexOf(part);\n//     if (idx !== -1) this.parts.splice(idx, 1);\n//   }\n\n//   displayDetails(): void {\n//     console.log(`Moped: ${this.name}`);\n//     for (const part of this.parts) {\n//       part.displayDetails();\n//     }\n//   }\n\n//   getPrice(): number {\n//     return this.parts.reduce((total, part) => total + part.getPrice(), 0);\n//   }\n// }\n\n// // Використання\n// const alphaMoped = new Moped('Alpha');\n\n// // Додаємо частини мопеда з цінами\n// const frame = new MopedPart('Frame', 1000);\n// const engine = new MopedPart('Engine', 5000);\n// const wheels = new MopedPart('Wheels', 2000);\n// const handlebar = new MopedPart('Handlebar', 50);\n\n// alphaMoped.addPart(frame);\n// alphaMoped.addPart(engine);\n// alphaMoped.addPart(wheels);\n// alphaMoped.addPart(handlebar);\n// // Видаляємо додану частину (наприклад, \"Handlebar\")\n// alphaMoped.removePart(handlebar);\n// // Виведення ієрархії мопеда та загальної ціни\n// alphaMoped.displayDetails();\n// console.log(`Total Price: ${alphaMoped.getPrice()}₴`);\n\n// ===============Flyweight==================================\n// // Інтерфейс Flyweight\n// interface IBook {\n//   id: number;\n//   title: string;\n//   author: string;\n// }\n\n// // Flyweight\n// class Book implements IBook {\n//   constructor(\n//     public readonly id: number,\n//     public readonly title: string,\n//     public readonly author: string\n//   ) {}\n// }\n\n// // Flyweight Factory для кешування книг\n// class BookFactory {\n//   private static readonly bookCache: Map<number, Book> = new Map();\n\n//   static getBook(id: number, title: string, author: string = 'user'): Book {\n//     if (!this.bookCache.has(id)) {\n//       console.log(`Creating new book: ${title} by ${author}`);\n//       this.bookCache.set(id, new Book(id, title, author));\n//     }\n//     return this.bookCache.get(id)!;\n//   }\n\n//   static getCacheSize(): number {\n//     return this.bookCache.size;\n//   }\n// }\n\n// // Використання\n// const book1 = BookFactory.getBook(1, '1984', 'George Orwell');\n// const book2 = BookFactory.getBook(2, 'To Kill a Mockingbird', 'Harper Lee');\n// const book3 = BookFactory.getBook(1, '1984', 'George Orwell'); // Взято з кешу\n\n// console.log(book1 === book3); // true, оскільки об'єкт береться з кешу\n// console.log(`Cache size: ${BookFactory.getCacheSize()}`); // 2\n\n// ==================================================\n// ---------------behavioral-------------------------\n// ==================================================\n\n// ===========Strategy================================\n// // Інтерфейс стратегії\n// interface PaymentStrategy {\n//   pay(amount: number): void;\n// }\n\n// // Реалізація стратегії оплати через кредитну картку\n// class CreditCardPayment implements PaymentStrategy {\n//   constructor(private readonly cardNumber: string) {}\n\n//   pay(amount: number): void {\n//     console.log(`Оплачено ${amount} грн за допомогою кредитної картки ${this.cardNumber}`);\n//   }\n// }\n\n// // Реалізація стратегії оплати готівкою\n// class CashPayment implements PaymentStrategy {\n//   pay(amount: number): void {\n//     console.log(`Оплачено ${amount} грн готівкою.`);\n//   }\n// }\n\n// // Контекст (користувач стратегії)\n// class PaymentProcessor {\n//   private strategy: PaymentStrategy | null = null;\n\n//   // Метод для встановлення стратегії\n//   setStrategy(strategy: PaymentStrategy): void {\n//     this.strategy = strategy;\n//   }\n\n//   // Виконання оплати\n//   processPayment(amount: number): void {\n//     if (!this.strategy) {\n//       console.log('Стратегію оплати не встановлено');\n//       return;\n//     }\n//     this.strategy.pay(amount);\n//   }\n// }\n\n// // Використання\n// const paymentProcessor = new PaymentProcessor();\n\n// // Оплата через кредитну картку\n// paymentProcessor.setStrategy(new CreditCardPayment('4434567898765432'));\n// paymentProcessor.processPayment(1000);\n\n// // Оплата готівкою\n// paymentProcessor.setStrategy(new CashPayment());\n// paymentProcessor.processPayment(700);\n\n// ============Template Method============================\n// // Абстрактний клас із шаблонним методом\n// abstract class BouquetMaker {\n//   public makeBouquet(): void {\n//     this.prepareBase();\n//     this.addFlowers();\n//     this.addDecorations();\n//     this.wrapBouquet();\n//   }\n\n//   // Спільні кроки\n//   protected prepareBase(): void {\n//     console.log('Підготовка основи для букета...');\n//   }\n\n//   protected wrapBouquet(): void {\n//     console.log('Упаковка букета...');\n//   }\n\n//   // Кроки, які мають реалізовувати підкласи\n//   protected abstract addFlowers(): void;\n//   protected abstract addDecorations(): void;\n// }\n\n// // Клас для класичного букета\n// class ClassicBouquetMaker extends BouquetMaker {\n//   protected addFlowers(): void {\n//     console.log('Додавання троянд та лілій...');\n//   }\n\n//   protected addDecorations(): void {\n//     console.log('Додавання стрічки...');\n//   }\n// }\n\n// // Клас для польового букета\n// class WildBouquetMaker extends BouquetMaker {\n//   protected addFlowers(): void {\n//     console.log('Додавання ромашок, волошок та лаванди...');\n//   }\n\n//   protected addDecorations(): void {\n//     console.log('Додавання сухоцвітів...');\n//   }\n// }\n\n// // Використання\n// const classicBouquet = new ClassicBouquetMaker();\n// console.log('Приготування класичного букета:');\n// classicBouquet.makeBouquet();\n\n// const wildBouquet = new WildBouquetMaker();\n// console.log('\\nПриготування польового букета:');\n// wildBouquet.makeBouquet();\n\n// ================Visitor============================\n// // Інтерфейс для відвідувача\n// interface FlowerVisitor {\n//   visitRose(rose: Rose): void;\n//   visitTulip(tulip: Tulip): void;\n//   visitDaisy(daisy: Daisy): void;\n// }\n\n// // Інтерфейс для квітів\n// interface Flower {\n//   accept(visitor: FlowerVisitor): void;\n// }\n\n// // Конкретна квітка: Троянда\n// class Rose implements Flower {\n//   constructor(public price: number) {}\n\n//   getName(): string {\n//     return 'Rose';\n//   }\n\n//   accept(visitor: FlowerVisitor): void {\n//     visitor.visitRose(this);\n//   }\n// }\n\n// // Конкретна квітка: Тюльпан\n// class Tulip implements Flower {\n//   constructor(public price: number) {}\n\n//   getName(): string {\n//     return 'Tulip';\n//   }\n\n//   accept(visitor: FlowerVisitor): void {\n//     visitor.visitTulip(this);\n//   }\n// }\n\n// // Конкретна квітка: Ромашка\n// class Daisy implements Flower {\n//   constructor(public price: number) {}\n\n//   getName(): string {\n//     return 'Daisy';\n//   }\n\n//   accept(visitor: FlowerVisitor): void {\n//     visitor.visitDaisy(this);\n//   }\n// }\n\n// // Конкретний відвідувач для підрахунку вартості букета\n// class PriceCalculatorVisitor implements FlowerVisitor {\n//   private totalPrice = 0;\n\n//   visitRose(rose: Rose): void {\n//     this.totalPrice += rose.price;\n//   }\n\n//   visitTulip(tulip: Tulip): void {\n//     this.totalPrice += tulip.price;\n//   }\n\n//   visitDaisy(daisy: Daisy): void {\n//     this.totalPrice += daisy.price;\n//   }\n\n//   getTotalPrice(): number {\n//     return this.totalPrice;\n//   }\n// }\n\n// // Конкретний відвідувач для створення опису букета\n// class DescriptionVisitor implements FlowerVisitor {\n//   private readonly description: string[] = [];\n\n//   visitRose(rose: Rose): void {\n//     this.description.push(rose.getName());\n//   }\n\n//   visitTulip(tulip: Tulip): void {\n//     this.description.push(tulip.getName());\n//   }\n\n//   visitDaisy(daisy: Daisy): void {\n//     this.description.push(daisy.getName());\n//   }\n\n//   getDescription(): string {\n//     return this.description.join(', ');\n//   }\n// }\n\n// // Використання\n// const bouquetArr: Flower[] = [new Rose(700), new Tulip(200), new Daisy(70)];\n\n// const priceCalculator = new PriceCalculatorVisitor();\n// const descriptionVisitor = new DescriptionVisitor();\n\n// function clientCode(bouquet: Flower[], visitor: FlowerVisitor) {\n//   bouquet.forEach(flower => flower.accept(visitor));\n// }\n\n// clientCode(bouquetArr, descriptionVisitor);\n// clientCode(bouquetArr, priceCalculator);\n\n// console.log(`Загальна вартість букета: ${priceCalculator.getTotalPrice()}грн.`);\n// console.log(`Опис букета: ${descriptionVisitor.getDescription()}.`);\n\n// ================Mediator============================\n// // Інтерфейс Посередника\n// interface Mediator {\n//   notify(sender: object, message: string): void;\n// }\n\n// // Конкретний Посередник\n// class WebMediator implements Mediator {\n//   private readonly frontend: Frontend;\n//   private readonly backend: Backend;\n\n//   constructor(frontend: Frontend, backend: Backend) {\n//     this.frontend = frontend;\n//     this.frontend.setMediator(this);\n\n//     this.backend = backend;\n//     this.backend.setMediator(this);\n//   }\n\n//   notify(sender: object, message: string): void {\n//     switch (sender) {\n//       case this.frontend:\n//         console.log('Посередник: Frontend надсилає повідомлення до Backend.');\n//         this.backend.receiveMessage(message);\n//         break;\n//       case this.backend:\n//         console.log('Посередник: Backend надсилає повідомлення до Frontend.');\n//         this.frontend.receiveMessage(message);\n//         break;\n//       default:\n//         console.log('Посередник: Невідоме джерело повідомлення.');\n//     }\n//   }\n// }\n\n// // Базовий клас для компонентів\n// class BaseComponent {\n//   protected mediator: Mediator | null = null;\n\n//   setMediator(mediator: Mediator): void {\n//     this.mediator = mediator;\n//   }\n// }\n\n// // Конкретні компоненти\n// class Frontend extends BaseComponent {\n//   sendMessage(message: string): void {\n//     console.log(`Frontend: Sending message: \"${message}\"`);\n//     if (this.mediator) {\n//       this.mediator.notify(this, message);\n//     }\n//   }\n\n//   receiveMessage(message: string): void {\n//     console.log(`Frontend: Received message: \"${message}\"`);\n//   }\n// }\n\n// class Backend extends BaseComponent {\n//   sendMessage(message: string): void {\n//     console.log(`Backend: Sending message: \"${message}\"`);\n//     if (this.mediator) {\n//       this.mediator.notify(this, message);\n//     }\n//   }\n\n//   receiveMessage(message: string): void {\n//     console.log(`Backend: Received message: \"${message}\"`);\n//   }\n// }\n\n// // Використання\n// const frontend = new Frontend();\n// const backend = new Backend();\n\n// const mediator = new WebMediator(frontend, backend);\n\n// console.log('Клієнт: Frontend надсилає повідомлення.');\n// frontend.sendMessage('Hello from Frontend!');\n\n// console.log('\\nКлієнт: Backend надсилає повідомлення.');\n// backend.sendMessage('Hello from Backend!');\n\n// ==================Observer================================\n// // Інтерфейс спостерігача (підписника)\n// interface Observer {\n//   update(flowerName: string): void;\n// }\n\n// // Інтерфейс суб'єкта (магазину)\n// interface Subject {\n//   addObserver(observer: Observer): void;\n//   removeObserver(observer: Observer): void;\n//   notifyObservers(flowerName: string): void;\n// }\n\n// // Реалізація суб'єкта (Інтернет-магазин)\n// class FlowerShop implements Subject {\n//   private observers: Observer[] = [];\n\n//   public addObserver(observer: Observer): void {\n//     this.observers.push(observer);\n//   }\n\n//   public removeObserver(observer: Observer): void {\n//     this.observers = this.observers.filter(obs => obs !== observer);\n//   }\n\n//   public notifyObservers(flowerName: string): void {\n//     for (const observer of this.observers) {\n//       observer.update(flowerName);\n//     }\n//   }\n\n//   public addNewFlower(flowerName: string): void {\n//     console.log(`\\nFlowerShop: Додано нову квітку - ${flowerName}`);\n//     this.notifyObservers(flowerName);\n//   }\n// }\n\n// // Реалізація спостерігача (Клієнта)\n// class Customer implements Observer {\n//   constructor(private readonly name: string) {}\n\n//   public update(flowerName: string): void {\n//     console.log(`${this.name}: Сповіщення - доступна нова квітка \"${flowerName}\"`);\n//   }\n// }\n\n// // Використання\n// const flowerShop = new FlowerShop();\n\n// const customer1 = new Customer('Олена');\n// const customer2 = new Customer('Максим');\n// const customer3 = new Customer('Анна');\n\n// // Підписуємо клієнтів\n// flowerShop.addObserver(customer1);\n// flowerShop.addObserver(customer2);\n// flowerShop.addObserver(customer3);\n\n// // Додаємо нові квіти\n// flowerShop.addNewFlower('Троянда');\n// flowerShop.addNewFlower('Орхідея');\n\n// // Відписуємо одного з клієнтів\n// flowerShop.removeObserver(customer2);\n\n// // Додаємо ще одну квітку\n// flowerShop.addNewFlower('Лілія');\n\n// =================State====================\n// // Інтерфейс стану гри\n// interface GameState {\n//   startRound(game: CSGOGame): void;\n//   play(game: CSGOGame): void;\n//   endRound(game: CSGOGame): void;\n// }\n\n// // Стан: Очікування гравців\n// class WaitingForPlayersState implements GameState {\n//   startRound(game: CSGOGame): void {\n//     console.log('Гравці підключені. Починаємо раунд!');\n//     game.setState(new RoundInProgressState());\n//   }\n\n//   play(): void {\n//     console.log('Не можна почати гру без усіх гравців.');\n//   }\n\n//   endRound(): void {\n//     console.log('Гра ще не розпочалася.');\n//   }\n// }\n\n// // Стан: Гра триває\n// class RoundInProgressState implements GameState {\n//   startRound(): void {\n//     console.log('Раунд запущений!');\n//   }\n\n//   play(game: CSGOGame): void {\n//     console.log('Гравці виконують завдання.');\n//     // Емулюємо завершення раунду\n//     const winner = Math.random() > 0.5 ? 'Терористи' : 'Контртерористи';\n\n//     console.log(`${winner} перемогли у цьому раунді!`);\n//     game.setState(new RoundEndState());\n//   }\n\n//   endRound(): void {\n//     console.log('Гра ще триває. Завершіть раунд!');\n//   }\n// }\n\n// // Стан: Кінець раунду\n// class RoundEndState implements GameState {\n//   startRound(game: CSGOGame): void {\n//     console.log('Починаємо новий раунд!');\n//     game.setState(new RoundInProgressState());\n//   }\n\n//   play(): void {\n//     console.log('Раунд завершено. Почніть новий раунд.');\n//   }\n\n//   endRound(): void {\n//     console.log('Раунд вже завершено.');\n//   }\n// }\n\n// // Контекст: Гра CS:GO\n// class CSGOGame {\n//   private state: GameState;\n\n//   constructor() {\n//     this.state = new WaitingForPlayersState();\n//   }\n\n//   setState(state: GameState): void {\n//     this.state = state;\n//   }\n\n//   startRound(): void {\n//     this.state.startRound(this);\n//   }\n\n//   play(): void {\n//     this.state.play(this);\n//   }\n\n//   endRound(): void {\n//     this.state.endRound(this);\n//   }\n// }\n\n// // Використання\n// const game = new CSGOGame();\n\n// game.play(); // Не можна почати гру без усіх гравців.\n// game.startRound(); // Гравці підключені. Починаємо раунд!\n// game.play(); // Раунд у розпалі! Гравці виконують завдання. (визначається переможець)\n// game.play(); // Раунд завершено. Почніть новий раунд.\n// game.startRound(); // Починаємо новий раунд!\n\n// ==================Iterator================================\n// // Інтерфейс ітератора\n// interface Iterator<T> {\n//   next(): IteratorResult<T>;\n//   hasNext(): boolean;\n// }\n\n// // Інтерфейс колекції\n// interface FlowerCollection {\n//   createIterator(): Iterator<Flower>;\n// }\n\n// // Інтерфейс товару\n// interface Flower {\n//   name: string;\n//   price: number;\n//   category: string;\n// }\n\n// // Конкретний ітератор для квітів\n// class FlowerIterator implements Iterator<Flower> {\n//   private index: number = 0;\n\n//   constructor(private readonly flowers: Flower[]) {}\n\n//   next(): IteratorResult<Flower> {\n//     if (this.hasNext()) {\n//       return {\n//         done: false,\n//         value: this.flowers[this.index++],\n//       };\n//     }\n//     return {\n//       done: true,\n//       value: undefined,\n//     };\n//   }\n\n//   hasNext(): boolean {\n//     return this.index < this.flowers.length;\n//   }\n// }\n\n// // Колекція \"Букети\"\n// class BouquetCollection implements FlowerCollection {\n//   private readonly bouquets: Flower[] = [];\n\n//   addBouquet(name: string, price: number): void {\n//     this.bouquets.push({ name, price, category: 'Букет' });\n//   }\n\n//   createIterator(): Iterator<Flower> {\n//     return new FlowerIterator(this.bouquets);\n//   }\n// }\n\n// // Колекція \"Кімнатні рослини\"\n// class IndoorPlantCollection implements FlowerCollection {\n//   private readonly plants: Flower[] = [];\n\n//   addPlant(name: string, price: number): void {\n//     this.plants.push({ name, price, category: 'Кімнатна рослина' });\n//   }\n\n//   createIterator(): Iterator<Flower> {\n//     return new FlowerIterator(this.plants);\n//   }\n// }\n\n// // Клас для виведення товарів\n// class FlowerShop {\n//   constructor(private readonly collections: FlowerCollection[]) {}\n\n//   displayAllFlowers(): void {\n//     this.collections.forEach(collection => {\n//       const iterator = collection.createIterator();\n\n//       let result = iterator.next();\n//       while (!result.done) {\n//         const flower = result.value;\n//         console.log(`${flower.name} (${flower.category}) - ${flower.price.toFixed(2)}₴`);\n//         result = iterator.next();\n//       }\n//       console.log('\\n');\n//     });\n//   }\n// }\n\n// // Використання\n// const bouquets = new BouquetCollection();\n\n// bouquets.addBouquet('Романтичний букет', 499.99);\n// bouquets.addBouquet('Весільний букет', 895.99);\n\n// const indoorPlants = new IndoorPlantCollection();\n\n// indoorPlants.addPlant('Фікус', 197.99);\n// indoorPlants.addPlant('Орхідея', 293.99);\n\n// const flowerShop = new FlowerShop([bouquets, indoorPlants]);\n// flowerShop.displayAllFlowers();\n\n// ===============Chain of Command=====================\n// // Інтерфейс для обробників\n// interface Middleware {\n//   setNext(handler: Middleware): Middleware;\n//   handle(request: HttpRequest): string | null;\n// }\n\n// // Клас для запитів\n// class HttpRequest {\n//   constructor(\n//     public user: string | null,\n//     public token: string | null,\n//     public data: any\n//   ) {}\n// }\n\n// // Базовий клас обробника\n// abstract class AbstractMiddleware implements Middleware {\n//   private next: Middleware | null = null;\n\n//   public setNext(handler: Middleware): Middleware {\n//     this.next = handler;\n//     return handler;\n//   }\n\n//   public handle(request: HttpRequest): string | null {\n//     if (this.next) {\n//       return this.next.handle(request);\n//     }\n//     return null;\n//   }\n// }\n\n// // Конкретні обробники\n// class AuthMiddleware extends AbstractMiddleware {\n//   public handle(request: HttpRequest): string | null {\n//     if (!request.user || !request.token) {\n//       return 'AuthMiddleware: Аутентифікація не вдалася.';\n//     }\n//     console.log('AuthMiddleware: Аутентифікація пройшла успішно.');\n//     return super.handle(request);\n//   }\n// }\n\n// class PermissionMiddleware extends AbstractMiddleware {\n//   public handle(request: HttpRequest): string | null {\n//     if (request.user !== 'admin') {\n//       return 'PermissionMiddleware: Доступ заборонений.';\n//     }\n//     console.log('PermissionMiddleware: Доступ дозволений.');\n//     return super.handle(request);\n//   }\n// }\n\n// class ValidationMiddleware extends AbstractMiddleware {\n//   public handle(request: HttpRequest): string | null {\n//     if (!request.data || typeof request.data !== 'object') {\n//       return 'ValidationMiddleware: Невірні дані.';\n//     }\n//     console.log('ValidationMiddleware: Дані правильні.');\n//     return super.handle(request);\n//   }\n// }\n\n// // Використання\n// const auth = new AuthMiddleware();\n// const permission = new PermissionMiddleware();\n// const validation = new ValidationMiddleware();\n\n// // Створюємо ланцюг\n// auth.setNext(permission).setNext(validation);\n\n// // Тестуємо з різними запитами\n// const requests = [\n//   new HttpRequest(null, null, { key: 'value' }), // Неавторизований запит\n//   new HttpRequest('user', 'token123', null), // Немає даних\n//   new HttpRequest('admin', 'token123', { key: 'value' }), // Успішний запит\n// ];\n\n// for (const request of requests) {\n//   console.log('Обробка нового запиту...');\n//   const result = auth.handle(request);\n//   if (result) {\n//     console.log(result);\n//   } else {\n//     console.log('Запит оброблений успішно.');\n//   }\n//   console.log('----------------------------');\n// }\n\n// ==================Command============================\n// // Інтерфейс Команди\n// interface Command {\n//   execute(): void;\n// }\n\n// // Мопед\n// class Moped {\n//   startEngine() {\n//     console.log('Мопед Альфа: двигун запущено!');\n//   }\n\n//   stopEngine() {\n//     console.log('Мопед Альфа: двигун вимкнено!');\n//   }\n// }\n\n// // Команда для запуску двигуна\n// class StartEngineCommand implements Command {\n//   private readonly moped: Moped;\n\n//   constructor(moped: Moped) {\n//     this.moped = moped;\n//   }\n\n//   execute(): void {\n//     this.moped.startEngine();\n//   }\n// }\n\n// // Команда для зупинки двигуна\n// class StopEngineCommand implements Command {\n//   private readonly moped: Moped;\n\n//   constructor(moped: Moped) {\n//     this.moped = moped;\n//   }\n\n//   execute(): void {\n//     this.moped.stopEngine();\n//   }\n// }\n\n// // Відправник (Invoker)\n// class RemoteControl {\n//   private command: Command | null = null;\n\n//   setCommand(command: Command): void {\n//     this.command = command;\n//   }\n\n//   pressButton(): void {\n//     if (this.command) {\n//       this.command.execute();\n//     } else {\n//       console.log('Команда не встановлена.');\n//     }\n//   }\n// }\n\n// // Використання\n// const moped = new Moped();\n// const startEngine = new StartEngineCommand(moped);\n// const stopEngine = new StopEngineCommand(moped);\n\n// const remote = new RemoteControl();\n\n// remote.setCommand(startEngine);\n// remote.pressButton(); // Output: Мопед Альфа: двигун запущено!\n\n// remote.setCommand(stopEngine);\n// remote.pressButton(); // Output: Мопед Альфа: двигун вимкнено!\n\n// =====================Memento=================================\n// Memento: Зберігає стан гравця\nclass PlayerMemento {\n  constructor(\n    private readonly health: number,\n    private readonly armor: number,\n    private readonly position: string\n  ) {}\n\n  getState(): { health: number; armor: number; position: string } {\n    return {\n      health: this.health,\n      armor: this.armor,\n      position: this.position,\n    };\n  }\n}\n\n// Originator: Гравець\nclass Player {\n  private health: number = 100;\n  private armor: number = 50;\n  private position: string = 'Spawn';\n\n  setState(health: number, armor: number, position: string): void {\n    this.health = health;\n    this.armor = armor;\n    this.position = position;\n    console.log(\n      `\\n Player: Стан змінено - Health: ${this.health}, Armor: ${this.armor}, Position: ${this.position}`\n    );\n  }\n\n  getState(): { health: number; armor: number; position: string } {\n    return Object.freeze({\n      health: this.health,\n      armor: this.armor,\n      position: this.position,\n    });\n  }\n\n  save(): PlayerMemento {\n    console.log(`Player: Зберігаю стан...`);\n    return new PlayerMemento(this.health, this.armor, this.position);\n  }\n\n  restore(memento: PlayerMemento): void {\n    const state = memento.getState();\n    this.health = state.health;\n    this.armor = state.armor;\n    this.position = state.position;\n    console.log(\n      `Player: Відновлено стан - Health: ${this.health}, Armor: ${this.armor}, Position: ${this.position}`\n    );\n  }\n}\n\n// Caretaker: Відповідає за управління збереженнями\nclass GameHistory {\n  private readonly history: PlayerMemento[] = [];\n\n  constructor(private readonly player: Player) {}\n\n  backup(): void {\n    console.log(`GameHistory: Зберігаю стан гравця...`);\n    this.history.push(this.player.save());\n  }\n\n  undo(): void {\n    if (this.history.length === 0) {\n      console.log(`GameHistory: Немає збережень для відновлення.`);\n      return;\n    }\n\n    const memento = this.history.pop();\n    console.log(`\\n GameHistory: Відновлюю стан гравця...`);\n    this.player.restore(memento!);\n  }\n\n  showHistory(): void {\n    console.log(`GameHistory: Історія станів:`);\n    this.history.forEach((memento, index) => {\n      const state = memento.getState();\n      console.log(\n        `  Стан #${index + 1} - Health: ${state.health}, Armor: ${state.armor}, Position: ${state.position}`\n      );\n    });\n  }\n}\n\n// Приклад використання\nconst player = new Player();\nconst gameHistory = new GameHistory(player);\n\nplayer.setState(80, 45, 'Mid');\ngameHistory.backup();\n\nplayer.setState(60, 30, 'B Site');\n\ngameHistory.backup();\n\nplayer.setState(30, 10, 'A Site');\n\ngameHistory.showHistory();\ngameHistory.undo();\ngameHistory.undo();\ngameHistory.undo();\n"],"names":["PlayerMemento","health","armor","position","Player","__publicField","memento","state","GameHistory","player","index","gameHistory"],"mappings":"82BA07CA,MAAMA,CAAc,CAClB,YACmBC,EACAC,EACAC,EACjB,CAHiB,KAAA,OAAAF,EACA,KAAA,MAAAC,EACA,KAAA,SAAAC,CAChB,CAEH,UAAgE,CACvD,MAAA,CACL,OAAQ,KAAK,OACb,MAAO,KAAK,MACZ,SAAU,KAAK,QAAA,CAEnB,CACF,CAGA,MAAMC,CAAO,CAAb,cACUC,EAAA,cAAiB,KACjBA,EAAA,aAAgB,IAChBA,EAAA,gBAAmB,SAE3B,SAASJ,EAAgBC,EAAeC,EAAwB,CAC9D,KAAK,OAASF,EACd,KAAK,MAAQC,EACb,KAAK,SAAWC,EACR,QAAA,IACN;AAAA,kCAAqC,KAAK,MAAM,YAAY,KAAK,KAAK,eAAe,KAAK,QAAQ,EAAA,CAEtG,CAEA,UAAgE,CAC9D,OAAO,OAAO,OAAO,CACnB,OAAQ,KAAK,OACb,MAAO,KAAK,MACZ,SAAU,KAAK,QAAA,CAChB,CACH,CAEA,MAAsB,CACpB,eAAQ,IAAI,0BAA0B,EAC/B,IAAIH,EAAc,KAAK,OAAQ,KAAK,MAAO,KAAK,QAAQ,CACjE,CAEA,QAAQM,EAA8B,CAC9B,MAAAC,EAAQD,EAAQ,WACtB,KAAK,OAASC,EAAM,OACpB,KAAK,MAAQA,EAAM,MACnB,KAAK,SAAWA,EAAM,SACd,QAAA,IACN,qCAAqC,KAAK,MAAM,YAAY,KAAK,KAAK,eAAe,KAAK,QAAQ,EAAA,CAEtG,CACF,CAGA,MAAMC,CAAY,CAGhB,YAA6BC,EAAgB,CAF5BJ,EAAA,eAA2B,CAAA,GAEfI,KAAAA,OAAAA,CAAiB,CAE9C,QAAe,CACb,QAAQ,IAAI,sCAAsC,EAClD,KAAK,QAAQ,KAAK,KAAK,OAAO,MAAM,CACtC,CAEA,MAAa,CACP,GAAA,KAAK,QAAQ,SAAW,EAAG,CAC7B,QAAQ,IAAI,+CAA+C,EAC3D,MACF,CAEM,MAAAH,EAAU,KAAK,QAAQ,IAAI,EACjC,QAAQ,IAAI;AAAA,uCAA0C,EACjD,KAAA,OAAO,QAAQA,CAAQ,CAC9B,CAEA,aAAoB,CAClB,QAAQ,IAAI,8BAA8B,EAC1C,KAAK,QAAQ,QAAQ,CAACA,EAASI,IAAU,CACjC,MAAAH,EAAQD,EAAQ,WACd,QAAA,IACN,WAAWI,EAAQ,CAAC,cAAcH,EAAM,MAAM,YAAYA,EAAM,KAAK,eAAeA,EAAM,QAAQ,EAAA,CACpG,CACD,CACH,CACF,CAGA,MAAME,EAAS,IAAIL,EACbO,EAAc,IAAIH,EAAYC,CAAM,EAE1CA,EAAO,SAAS,GAAI,GAAI,KAAK,EAC7BE,EAAY,OAAO,EAEnBF,EAAO,SAAS,GAAI,GAAI,QAAQ,EAEhCE,EAAY,OAAO,EAEnBF,EAAO,SAAS,GAAI,GAAI,QAAQ,EAEhCE,EAAY,YAAY,EACxBA,EAAY,KAAK,EACjBA,EAAY,KAAK,EACjBA,EAAY,KAAK"}